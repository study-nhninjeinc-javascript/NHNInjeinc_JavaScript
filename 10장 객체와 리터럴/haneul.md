# 객체 리터럴
## 객체란?

 자바스크립트는 <b>객체 기반</b> 프로그래밍 언어로, 자바스크립트를 구성하는 거의 모든 것이 <b>객체</b>다.

### 원시 타입

  단 하나의 값만 나타내지만 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조.

🔎 원시 값은 변경 불가능한 값이지만 객체 타입의 값은 변경 가능한 값이다.

```jsx
var person = {
	name: 'Lee',
	age: 20
};
```

- 해당 코드에서 <b>person</b> 객체는 <b>name</b>과 <b>age</b>를 <b>프로퍼티</b>로 가지고 있다.

🔎 <b>프로퍼티</b>는 <b>키와 값</b>으로 구성되며 함수도 프로퍼티의 값이 될 수 있다. 이때 프로퍼티의 값이 된 함수는 <b>메서드</b>라고 부른다.

```jsx
var person = {
	name: 'Lee',
	age: 20,
	getOld: function() {
		this.age++;
	}
}
```
<br><br>

## 객체 리터럴

### 객체 생성

🔎 자바 같은 클래스 기반 객체지향 언어는 클래스를 new 연산자와 함께 생성자를 호출하여 <b>인스턴스</b>를 생성하는 방식으로 객체 생성

🔎 인스턴스는 클래스에 의해 생성되어 <b>메모리에 저장된 실체</b>를 말한다.

- 자바스크립트는 프로토타입 기반 객체지향 언어로 다양한 객체 생성 방법을 지원한다

<aside>
💡 <b>객체 리터럴</b>, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6)

</aside>

- 객체 리터럴은 객체를 생성하기 위한 표기법으로 중괄호(<b>{ … }</b>) 내에 0개 이상의 프로퍼티를 정의한다.

🔎 객체 리터럴은 코드 블록과 같이 중괄호를 사용하지만 코드 블록을 의미하지 않는다. 객체 리터럴은 값으로 평가되는 표현식으로 닫는 중활호 뒤에 세미콜론을 붙인다.

<br><br>

## 프로퍼티

### 프로퍼티 규칙

- 프로퍼티 나열 시 쉽표로 구분
    - 마지막 프로퍼티 뒤에는 쉼표 사용 X, BUT 사용해도 무관하다.
- 프로퍼티의 키는 <b>반드시 식별자 네이밍 규칙을 따라야 하는 것은 아니다.</b>

🔎 프로퍼티 키가 <b>식별자 네이밍 규칙</b>을 준수하는 못한 경우에는 따옴표(’’, “”)로 묶어야 한다. 그러나 프로퍼티 키가 식별자 네이밍 <b>규칙을 준수하는 경우에는 이를 생략 할 수 있다.</b>

```jsx
var person = {
	firstName: 'Ha-neul',
	'last-name': 'Lee'
//last-name: 'Lee' // SyntaxError
};
```

- 해당 코드에서 프로퍼티 키 중 firstName은 식별자 네이밍 규칙을 준수하고 있으나, ‘last-name’은 ‘-’ 연산자로 식별자 네이밍 규칙을 준수하고 있지 않다. 그렇기 때문에 따옴표로 묶어주어야 한다.

```jsx
var obj = {};
var key = 'hello';

// 프로퍼티 키 동적 생성
obj[key] = 'world';
```

- 프로퍼티 키에 문자열이나 심벌외의 값을 사용하면 <b>암묵적 타입 변환</b>을 통해 문자열이 된다.

```jsx
var typeCast = {
	0: 1,
	1: 2,
	2: 3
};
```

- 이미 존재하는 <b>프로퍼티 키를 중복 선언 시 나중에 선언한 프로퍼티가 기존 프로퍼티를 덮어쓴다.</b>

<br><br>

## 프로퍼티 접근, 생성, 갱신, 삭제

### 프로퍼티 접근 연산자
- 마침표 프로퍼티 접근 연산자를 사용하는 마침표 표기법
- 대괄호 프로퍼티 접근 연산자를 사용하는 대괄호 표기

### 프로퍼티 생성, 갱신, 삭제

```jsx
var person = {
	name: 'Lee'
};

// 프로퍼티 동적 생성
person.age = 20;

// 프로퍼티 갱신
person.name = 'Kim';

// 프로퍼티 삭제
// 객체에 프로퍼티가 존재하면 삭제한다. (delete 연산자)
delete person.age;

// 객체에 프로퍼티가 존재하지 않으면 삭제할 수 없다.
// BUT 에러가 발생하지 않는다.
delete person.age
```

<br><br>

## ES6에서 추가된 객체 리터럴의 확장 기능

## 프로퍼티 축약 표현

- 프로퍼티 값은 변수에 할당된 값을 가질 수도 있다.

```jsx
var a = 1, b = 2;

var obj = {
	a: a, // 1
	b: b  // 2
};

// ES6에서는 프로퍼티 값으로 변수를 사용한 경우 키를 생략할 수 있다.
// 이때 프로퍼티 키는 변수 이름으로 자동 생성된다.
var obj = {
	a, // a: a
	b  // b: b
}
```

## 계산된 프로퍼티 이름

- 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다.
    - 사용할 표현식을 대괄호(<b>[ … ]</b>)로 묶어야 한다. 이를 계산된 프로퍼티 이름이라고 한다.

```jsx
var prefix = 'prop';
var i = 0;

var obj = {};

obj[prefix + '-' + ++i] = i; // { prop-1: 1 }
obj[prefix + '-' + ++i] = i; // { prop-2: 2 }
obj[prefix + '-' + ++i] = i; // { prop-3: 3 }

// ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름을 사용할 수 있다.
const CONST_OBJ = {
	['${prefix}-${++i}']: i, // { prop-4: 4 }
	['${prefix}-${++i}']: i, // { prop-5: 5 }
	['${prefix}-${++i}']: i // { prop-6: 6 }
}

// ${} 표현식을 사용해 좀더 편하게 객체 리터럴 내부에서 계산된 프로퍼티 이름을 사용할 수 있다.
```

## 메서드 축약 표현

```jsx
// ES5
var obj = {
	name: 'Lee',
	sayHi: function() {
		console.log('Hi! ' + this.name); // Hi! Lee
	}
};

//ES6
const CONST_OBJ = {
	name: 'Lee',
	// 메서드 축약 표현
	sayHi() {
		console.log('Hi! ' + this.name); // Hi! Lee
	}
};
```