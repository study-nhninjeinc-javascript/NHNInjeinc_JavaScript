# 13. 스코프 (Scope)

```jsx
function add(x, y) {
	// 매개변수 x, y는 함수 몸체 내부에서만 참조할 수 있다.
	// 즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부라고 할 수 있다.
	console.log(x, y);
	return x + y;
}

add(2, 5); // 7

console.log(x, y); // -> error : x is not defined
```

```jsx
var var1 = 1; // 코드의 가장 바깥 영역에서 선언한 변수

if (true) {
	var var2 = 2; // 코드 블록(if) 내에서 선언한 변수
	if (true) {
		var var3 = 3; // 중첩된 코드 블록(if -> if) 내에서 선언한 변수
	}
}

function foo() {
	var var4 = 4; // 함수 내에서 선언한 변수
	
	function bar() {
		var var5 = 5; // 중첩된 함수 내에서 선언한 변수
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
// console.log(var4); // -> error : var4 is not defined
// console.log(var5); // -> error : var5 is not defined
```

- 변수는 자신이 선언된 위치에 의해 자신이 유효한 범위가 결정된다.
    - 유효한 범위 → 다른 코드가 자신을 참조할 수 있는 범위
- 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. → 이를 스코프라고 한다!

> 스코프는 식별자가 유효한 범위를 말한다.
> 

```jsx
var x = 'global'; // 코드의 가장 바깥 영역에서 선언한 변수

function foo() {
	var x = 'local'; // 함수 내에서 선언한 변수
	
	console.log(x); // local
}

foo(); // 변수 x를 출력하는 함수 foo를 호출한다.

console.log(x); // global
```

---

- 자바스크립트 엔진은 이름이 같은 두 개의 변수 중 어떤 변수를 참조해야 할 것인지를 결정해야 한다. 이를 식별자 결정이라고 한다.
    - 식별자 결정 시 스코프를 사용한다!
    - 즉 스코프는 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.
- 위 예제에서 코드의 가장 바깥 영역에서 선언된 x 변수는 어디서든 참조가 가능하다.
- foo 함수 내부에서 선언된 x 변수는 foo 함수 내부에서만 참조될 수 있고 foo 함수 외부에서는 참조할 수 없다.
- 이때 두 개의 x 변수는 식별자 이름이 동일하나 스코프(자신이 유효한 범위)가 다른 별개의 변수다.

<aside>
💡 렉시컬 환경(Lexical Environment)
- 코드가 어디서 실행되며 주변에 어떤 코드가 있는지 정보를 담은 것
  → 코드의 문맥은 렉시컬 환경으로 이뤄진다.
이를 구현한 것이 실행 컨텍스트이며, 모든 코드는 실행 컨텍스트에서 평가되고 실행됨

</aside>

- 스코프라는 개념이 없다면 같은 이름을 갖는 변수는 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용 할 수 없다.
- 식별자는 어떤 값을 구별할 수 있어야 하므로 유일해야한다.
    - 식별자인 변수 이름은 중복될 수 없다.
- 하나의 값은 유일한 식별자에 연결 되어야 한다.

> 프로그래밍 언어에서는 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다.
스코프 내에서 식별자는 유일해야하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다!
> 

### 즉, 식별자는 네임스페이스다.

🔍 네임스페이스는 프로그램상에서 개체를 구분할 수 있는 범위를 말한다.

- var, let, const 키워드의 중복선언

```jsx
// var 키워드는 같은 스코프 내에서 중복 선언이 가능하다.
function varFunc() {
	var x = 1;

	var x = 2; // 중복 선언 시 기존 변수에 재할당 한다 (자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작)
	console.log(x);
}

varFunc(); // 2

// let, const 키워드는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
function letFunc() {
	let x = 1;
	
	let x = 2; // error : Identifier 'x' has already been declared
}

letFunc();
```

## 스코프의 종류

### 전역 스코프

- 코드의 가장 바깥 영역이다.
- 전역 스코프에서 선언한 변수는 전역 스코프를 갖는 전역 변수이다.
- 전역 변수는 어디서든지 참조할 수 있다.

### 지역 스코프

- 함수 본체 내부 영역이다.
- 지역 스코프에서 선언된 변수는 지역 스코프를 갖는 지역 변수이다.
- 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

```jsx
// 전역 스코프 시작
var x = 'global x';
var y = 'global y';

// 지역 스코프 시작
function outer() {
	var z = 'outer local z';

	console.log("${x} ${y} ${z}"); // global x global y outer local z
	
	// 하위 지역 스코프 시작
	function inner() {
		var x = 'inner local x';

		console.log("${x} ${y} ${z}"); // innser local x global y outer local z
	}
	// 하위 지역 스코프 끝

	inner();
}
// 지역 스코프 끝

outer();

// 전역 스코프 끝
```

### 스코프 체인 형태

![scope chain.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f74f58f5-0fc3-4c17-b78f-3f0dd7cdf212/scope_chain.png)

## 스코프 체인

- 함수는 중첩될 수 있으며, 함수 몸체 내부에서 정의한 함수를 ‘중첩 함수’, 중첩 함수를 포함하는 함수를 ‘외부 함수’라고 한다.
- 함수는 중첩될 수 있으므로 지역 스코프도 중첩될 수 있다.
    - 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다.

🔍 외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라고 한다.

## 스코프 체인에 의한 변수 검색

- [위 예제를 통해 자바스크립트 엔진이 스코프 체인을 통해 어떻게 변수를 찾아내는지 이해할 수 있다.](https://www.notion.so/3-1b4cc5456a7b4fe7bec0564e640d208a)

<aside>
💡 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.
식별자 검색 시 자신의 소코프에서 검색을 시작해 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. (절대 하위 스코프로 내려가면서 식별자를 검색하지 않는다!)

</aside>

## 스코프 체인에 의한 함수 검색

```jsx
function foo() {
	console.log('global function foo');
}

function bar() {
	// 중첩 함수
	function foo() {
		console.log('local function foo');
	}

	foo();
}

bar();
```

- 이미 알고 있듯 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다.
    - 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.
- 함수는 식별자에 함수 객체가 할당된 것 외에는 일반 변수와 다를 바 없다.

## 함수 레벨 스코프

```jsx
var x = 1;

if (true) {
	// 이때 var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.
	// 즉 해당 변수 var 키워드가 없는 것처럼 실행되어 기존에 선언한 변수에 재할당하게 된다.
	var x = 10;
	console.log(x); // 10
}

console.log(x); // 10
```

- 지역 스코프는 코드 블록이 아닌 함수에 의해서만 생성된다!
    - C나 자바 등 대부분의 프로그래밍 언어는 함수 몸체만이 아닌 모든 코드 블록이 지역 스코프를 만든다. 이를 블록 레벨 스코프라고 한다.
    - 자바스크립트에서 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이를 함수 레벨 스코프라고 한다.

> ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원한다!
> 

```jsx
let x = 'global';

if (true) {
	let x = 'local'
	console.log(x); // local
}

console.log(x); // global
```

## 렉시컬 스코프

```jsx
var x = 1;

function foo() {
	var x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo();
bar();
```

- 프로그래밍 언어에서 함수의 상위 스코프를 결정할 때 보통 호출 시점과 정의 시점 중 한 가지 방식으로 함수의 상위 스코프를 결정한다.
    - 위 예제에서 호출 시점으로 상위 스코프를 결정한다면 bar 함수의 상위 스코프는 foo 함수의 지역 스코프와 전역 스코프가 된다.
        - 이러한 방식을 동적 스코프라고 한다.
    - 위 예제에서 정의 시점으로 상위 스코프를 결정한다면 bar 함수의 상위 스코프는 전역 스코프가 된다.
        - 이러한 방식을 렉시컬 스코프(정적 스코프)라고 한다.
        - 자바스크립트를 포함한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

> 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.
즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프다. ( 위 예제에서 foo와 bar의 상위 스코프는 전역 스코프가 된다.)
→ 위 예제에서 결과는 1 이 두 번 출력 된다.
>