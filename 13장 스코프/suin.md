# 13장 스코프

## 13.1 스코프란?

- **모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할수있는 유효범위가 결정된다**. → 이를 스코프라고 한다.
사전 - **scope** : 명) 기회[여지/능력], **범위**

```jsx
function add(x,y){
		//매개변수는 함수 몸체 내부에서만 참조 할수 있다.
		//-> 매개변수의 스코프(유효범위)는 함수 몸체 내부다.
    console.log(x, y);
		return x+y;
}
add(2, 5);//2 5
console(x, y); //Uncaught ReferenceError: x is not defined

var var1 = 1;
if(true){
		var var2 = 2;
		if(true){
			var2 = 3;
		}
}

function foo(){
		var var4 = 4;
		function bar(){
			var var5 = 5;
		}
}
console.log(var1);//1
console.log(var2);//3
console.log(var3);//Uncaught ReferenceError: var3 is not defined
console.log(var4);//Uncaught ReferenceError: var4 is not defined
console.log(var5);//Uncaught ReferenceError: var5 is not defined
```

- **식별자 결정** : 자바스크립트 엔진이 같은 두개의 변수 중에서 어떤 변수를 참조해야할것인지 결정 하는 것

```jsx
var x = 'global';
funcntion foo(){
		var x = 'local';
		console.log(x);//local
}
foo();
console.log(x);//global
//왜 1번은 local 2번은 global일까
//foo안의 x는 함수내부에서 선언되어 내부에서만 참조가능
//밖의 x는 전체에서 사용가능
//그렇다면 foo안에서 x는 왜? 내부것으로 참조가 될까?
//var - 함수스코프를 따름, 자신이 선언된 곳과 가장 가까운 함수를 유효범위로 가짐
//let const - 블록 스코프를 따르는데 자신이 선언된 곳과 가장 가까운 블록을 유효범위로 가짐
//일단 이부분 스코프 체인에서 나중에 할 것 같다. -일단 패스

```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b0fdb596-a1d4-485b-8da6-8ca45093959f/Untitled.png)

- 따라서 스코프란 **자바스크립트 엔진이 식별자를 검색할때 사용하는규칙**이라고도 할수있다.
- 자바스크립트 엔진은 코드를 실행할때 코드의 문맥을 고려
    - 코드 문맥과 환경
        
        코드가 어디서 실행되며 주변에 어떤코드가 있는지를 렉시컬환경이라고 부른다.
        → 코드의 문맥은 렉시컬 환경으로 이뤄진다. 이를 구현한것이 실행컨텍스트 이며 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. - 23장에서 곧 살펴볼 예정
        
- 식별자는 어떤 값을 구별할 수있어야 하므로 유일해야한다. → 식별자인 변수이름은 중복될수없다. → 하나의 값은 유일한 식별자에 연결되어야한다.
- 그런데 위 소스는 변수명이 같으나 스코프가 다르기 때문에 별개의 변수임 - 헷갈리지 말것
- 프로그래밍 언어에서는 스코프를 통해 식별자인 변수 이름의 충돌을 방지
→ 스코프내에서 식별자는 유일해야하지만, 다른 스코프에서는 같은 이름의 식별자를 사용할수 있게한다.
→ 스코프는 네임스페이스다.

var 키워드로 선언된 변수는 같은 스코프내에서 중복선언이 허용이 된다. - 이는 의도치않게 변수값이 재할당 되어 변경되는 부작용을 발생시킨다.

→ let이나 const는 중복선언 허용하지 않는다.

```jsx
function foo(){
		var x = 1;
		var x = 2;
		console.log(x);//2
}
foo();
function bar(){
		let x = 1;
		let x = 2;//Uncaught SyntaxError: Identifier 'x' has already been declared
}
bar();
```

식별자? : 어떤 값을 구별하여 식별해 낼수있는 고유한 이름

네임 스페이스 : 이름공간, 내부 식별자(형식, 함수, 변수 등의 이름)에 범위를 제공하는 선언적 영역

---

## 13.2 스코프의 종류

- 코드는 전역과 지역으로 구분할 수 있다
    
    
    | 구분 | 설명 | 스코프 | 변수 |
    | --- | --- | --- | --- |
    | 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역변수 |
    | 지역 | 함수 몸체 내부 | 지역 스코프 | 지역변수 |
- 변수는 자신이 선언된 위치에의해 자신이 유효한 범위인 스코프가 결정된다.
→ 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수
    지역에서 선언된 변수는 지역 스코프를 같는 지역 변수

### 13.2.1 전역과 전역 스코프

- 전역이란 코드의 가장 바깥영역 - 전역 스코프를 만든다. - 전역에 변수를 선언하면 전역스코프를 같는 전역변수가 된다.
- 전역변수는 어디서든지 참조할수있다.

### 13.2.2 지역과 지역 스코프

- 지역이란 함수몸체 내부 - 지역스코프를 만든다. - 지역에 변수를 선언하면 지역스코프를 갖는 지역 변수가 된다.
- 지역변수는 자신이 선언되 지역과 하위 지역에서만 참조할수있다. → 지역변수는 자신의 지역스코프와 하위 지역 스코프에서 유효하다

## 13.3 스코프 체인

- 함수는 전역에서 정의할수도 함수몸체 내부에서 정의할수도있다.
함수의 중첩 : 함수몸체 내부에서 함수가 정의된것
중첩함수 : 함수 몸체 내부에서 정의한 함수
외부함수 : 중첩함수를 표함하는 함수
→ 이부분은 12장 함수에서 배웠던 부분
- 함수는 중첩될수 있으므로 함수의 지역 스코프도 중첩될수있다
→ **스코프가 함수의 중첩에 의해 계층적 구조를 갖는다**는 것을 의미한다
- 모든 스코프는 하나의 계층적 구조로 연결
모든 지역 스코프의 최상위 스코프는 전역스코프이다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03f528d2-cb90-4179-ab1f-0a914eca8342/Untitled.png)

- **스코프 체인 : 스코프가 계층적으로 연결된것**
- **변수를 참조할때 자바스크립트 엔진은 스코프체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.**
→ 이를 통해 상위스코프에서 선언한 변수를 하위스코프에서도 참조할수있다.
- 스코프체인은 물리적인 실체로 존재한다.
자바스크립트 엔진은 코드를 실행하기 앞서 렉시컬 환경을 실제로 생성
    
    변수선언이 실행되면 변수식별자가 이 자료구조에 키로 등록
    변수 할당이 일어나면 이자료구조의 변수식별자에 해당하는 값을 변경
    변수의 검색도 이 자료구조상에서이뤄진다.
    
    - 렉시컬환경
        
        특정 코드가 작성 선언된 환경
        스코프 체인은 실행컨텍스트에 렉시컬 환경을 단방향으로 연결 한것이다.
        전역 렉시컬 환경은 코드가 곧바로 생성
        함수의 렉시컬 환경은 함수가 호출 되면 곧바로 생성 → 23장에서 자세히 나온다고 한다.
        

### 13.3.1 스코프 체인에 의한 변수 검색

- 자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색
- 절대 하위 스코프로 내려가면서 식별자를 검색 X
- 상위 스코프에서 유효한 변수는 하위 스코프에서 참조 O
하위 스코프에서 유효한 변수를 상위 스코프에서 참조 X

### 13.3.1 스코프 체인에 의한 함수 검색

- 함수도 식별자에 할당되기 때문에 스코프를 가짐
→ 스코프를 식별자를 검색하는 규칙이라고 표현하는 편이 좀 더 적합하다.

```jsx
function foo(){
	console.log('test');
}
function bar(){
	function foo(){
		console.log('나는 중첩함수야');
	}
	foo();
}
bar();
//나는 중첩함수야가 콘솔에 찍힘
```

```jsx
var x = '나는 x';
var y = '나는 y';

function outer(){
		var z = 'outer z';
		console.log(x);
		console.log(y);
		console.log(z);
		function inner(){
			var x = 'inner x';
			console.log(x);  //1
			console.log(y);
			console.log(z);
		}
		inner();
}

outer();
console.log(x);        //2
console.log(z);        //3
```

**쉬운 중간 문제**

1. 이부분은 어떤 스코프일까요?
2. 이부분의 상위 스코프는 어디일까요?
3. 모든지역의 최상위 스코프는 OO OOO이다.

---

## 13.4 함수레벨 스코프

- 지역은 함수 몸체 내부를 말하고, 지역은 지역스코프를 만든다
→ **코드블록이 아닌 함수에 의해서만 지역스코프가 생성된다.**
- 대부분의 프로그래밍 언어는 코드 블록이 지역스코프를 만든다. → 블록레벨스코프
- 그러나 var 키워드로 선언된 변수는 오로지 **함수의 코드 블록만을 지역스코프로 인정**한다. → **함수레벨스코프**
- let, const 키워드는 블록레벨 스코프를 지원 → 15장에서 살펴볼 수 있다.

예제소스

```jsx
var x = 1;
if(true){
	var x = 10;
}
console.log(x);//10

var i = 10;
for(var i = 0; i < 5; i++){
	console.log('');
}
console.log(i); //5

//만약 let으로 바꾸면 어떻게 될까요?
```

## 13.5 렉시컬 스코프

```jsx
var x = 1;
function foo(){
	var x = 10;
	bar();
}
function bar(){
	console.log(x);
}
foo(); //
bar(); //
```

- **함수를 어디서 호출**했는지에 따라 함수의 상위 스코프를 결정 : 동적스코프
→ 함수가 호출되는시점에 동적으로 스코프를 경정하기 때문
- **함수를 어디서 정의**했는지에따라 함수의 상위스코프를 결정 : 렉시컬 스코프(정적 스코프)
→ 함수정의가 평가되는 시점에서 상위스코프가 정적으로 결정
- 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 **렉시컬 스코프**를 따른다.
- 자바스크립트는 렉시컬스코프를 따른다.
**함수를 어디서 정의했는지에 따라 상위스코프를 결정**
함수가 호출된 위치는 상위스코프 결정에 어떠한 영향도 주지않는다.
→ 함수의 상위스코프는 언제나 자신이 정의된 스코프이다.
- 함수의 상위 스코프는 함수 정의가 실행될때 정적으로 결정
함수 정의가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억 → 함수가 호출될때마다 함수의 상위 스코프를 참조할 필요가 있기 때문.
- 렉시컬 스코프는 클로저와 깊은 관계가 있다. → 24장에서 자세히 살펴볼 예정