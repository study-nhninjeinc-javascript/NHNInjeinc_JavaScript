## 12.1 함수란?

- 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.

함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 함.

## 12.2 함수를 사용하는 이유

- 코드의 재사용 측면에서 유용
- 유지보수의 편의성
- 코드의 신뢰성

적절한 함수 이름 → 코드의 가독성 향상

## 12.3 함수 리터럴

- 리터럴이란 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식.
- 함수 리터럴은 function 키워드, 함수 이름, 매겨 변수 목록, 함수 몸체로 구성

```jsx
// 변수에 함수 리터럴을 할당
var f = function add(x, y){
	return x + y;
}
```

## 12.4 함수 정의

- 함수 정의 방식에는 함수 선언문, 함수 표현식, Function  생성자 함수, 화살표 함수가 있다.

### 12.4.1 함수 선언문

- 함수 선언문은 함수 리터럴과 달리 함수 이름을 생략할 수 없음.
- 함수 선언문은 표현식이 아닌 문이다.

기명 함수 리터럴은 코드의 문맥에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석됨, 단독으로 사용하면 함수 선언문, 피연산자로 사용하면 함수 리터럴 표현식으로 해석됨.

```jsx
//기명함수리터럴 단독사용
//foo는 자바스크립트 엔진이 암묵적으로 생성한 식별자이다.
function foo(){ console.log('foo');}
foo(); //foo

//기명함수리터럴 피연산자로 사용
//함수 이름 bar는 함수 몸체 내에서만 참조할 수 있는 식별자이므로 함수를 호출할 수 없음
(function bar(){ console.log('bar');});
bar() //ReferenceError~~~어쩌구
```

자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다. 다시 말하면 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다~~

### 12.4.2 함수 표현식

- 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있는데 이러한 함수 정의 방식을 함수 표현식이라 한다.

### 12.4.3 함수 생성 시점과 함수 호이스팅

- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름. 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 식별자도 생성하고 함수 객체를 할당한다! 이처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅 이라 한다.
- 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅(undefined로 초기화 되는?)이 발생한다.

### 12.4.4 Function 생성자 함수

```jsx
//Function 생성자 함수
var add = new Function('x', 'y', 'return x + y');
console.log(add(2, 5)); //7
```

### 12.4.5 화살표 함수

```jsx
//화살표 함수
var add = (x, y) => x + y;
console.log(add(2,5)); //7
```

## 12.5 함수 호출

### 12.5.1 매개변수와 인수

- 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined 이다.

### 12.5.2 인수 확인

- 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음
- 자바스크립트는 동적 타입 언어이기 때문에 함수의 배개변수 타입을 사전에 지정할 수 없다.

### 12.5.3 매개변수의 최대 개수

### 12.5.4 반환문

- 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나가는 역할을 하고, return 키워드 뒤에 오는 표현식을 평가해 반환하는 역할을 함. 표현식을 명시적으로 지정하지 않으면 undefined가 반환!

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 따름.
- 함수 외부에서 함수 몸체 내부로 전달한 원시 값의 원본을 변경하는 어떠한 효과도 발생하지 않음. 하지만 객체 타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에 객체를 변경할 경우 원본이 훼손되는데 이러한 문제는 참조에 의한 전달 방식으로 동작하기 때문에 발생하는 부작용이다.
    
    해결방법 중 하나 : 객체를 불변 객체로 만들어 사용하기!
    
    객체의 복사본을 새롭게 생성하여 원시값처럼 변경 불가능한 값으로 동작하게 만드는 것
    

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

- 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 함. 단 한번만 호출되며 다시 호출할 수 없음.

```jsx
//익명 즉시 실행 함수
(function(){
	var a = 3;
	var b = 5;
	return a * b;
}()); //15
```

- 즉시 실행 함수는 반드시 그룹 연산자(…)로 감싸야함. 아니면 에러발생
- 즉시 실행 함수도 일반 함수처럼 값을 반활할 수 있고 인수를 전달할 수 있다.

### 12.7.2 재귀 함수

- 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 재귀 함수라고 함.

```jsx
function countdown(n){
	if(n < 0) return;
	console.log(n);
	countdown(n-1);
}

countdown(10);
```

- 함수 내부에서 자기 자신을 호출할 때 사용한 countdown은 함수 이름이다. 함수 이름은 함수 몸체 내부에서만 유효하므로 함수 내부에서는 함수 이름을 사용해 자기 자신을 호출할 수 있다. 함수 외부에서는 함수를 호출할 때 반드시 함수를 가리키는 식별자로 해야함.

### 12.7.3 중첩 함수

- 함수 내부에 정의된 함수를 중첩함수 또는 내부 함수 라고 함. 그리고 중첩 함수를 포함하는 함수는 외부 함수라고 부름.

### 12.7.4 콜백 함수

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받음 함수를 고차 함수 라고 함.

```jsx
function repeat(n,f){
	for(var i = 0; i < n; i++){
		f(i);
	}
}

var logAll = function(i){
	console.log(i);
};

repeat(5,logAll); //0 1 2 3 4
```

- 여기서 logAll 함수는 단 한번만 생성되지만 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하면 고차 함수가 호출될 때마다 콜백 함수가 생성됨.

### 12.7.5 순수 함수와 비순수 함수

- 부수 효과가 없는(어떤 외부 상태에 의존하지도 않고 변경하지도 않는) 함수를 순수 함수, 부수 효과가 있는 함수를 비순수 함수라 함.
- 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다. 함수가 외부 상태를 변경하면 상태 변화 추적이 어려워짐.