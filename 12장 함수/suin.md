# 11장 원시값과 객체의 비교 (2)

- 자바스크립트의 타입은 원시타입과 객체타입으로 구분할 수 있다
- 원시타입과 객체타입의 차이점
- 원시타입의 값은 변경 불가능, 객체(참조) 타입의 값은 변경이 가능
- 변수에 할당 시 - 원시 값 :  변수에는 실제 값이 저장
                           - 객체 값 : 변수에는 참조 값이 저장
- 변수를 다른 변수에 할당 시 - 원시 타입 : 값이 복사되어 전달 → 값에 의한 전달
                                                - 객체 타입 : 참조값이 복사되어 전달 → 참조에 의한 전달
- 

---

## 11.1 원시 값

1. **변경 불가능한 값**
    - 한번 생성된 원시 값은 **읽기 전용 값으로 변경 할 수 X** - 데이터 신뢰성을 보장
    - 변경 불가능 하다는 것은 변수가 아니라 값에 대한 진술이다.
        - 변수와 상수
            
            변수
            
            - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
            - 언제든지 재할당을 통해 변수 값을 변경할 수 있다.
            
            상수
            
            - 한번만 할당 가능, 변경이 불가능한 값 X, 재할당이 금지 된변수
    - 원시값이 변경 불가능 한 값이기 때문에 변수를 재할당 시 참조하던 메모리 주소가 변경된다. - 이러한 특성을 **불변성**이라한다.
2. **문자열과 불변성**
    - 원시값을 저장하려면 먼저 확보 해야하는 메모리 공간의 크기를 결정해야한다
    - 이를 위해 원시 타입 별로 메모리 공간의 크기가 미리 정해져 있다.
    - 문자열은 다른 원시 값과 비교할 때 독특한 특징이 있다.
    - 0개 이상 문자로 이뤄진 집합 - 1개의 문자는 2바이트의 메모리 공간에 저장
    - 몇 개의 문자로 이뤄졌냐에 따라 메모리 크기가 결정
    - 문자열도 원시 타입이기 때문에 변경 불가
    똑같이 변수에 재할당 시 메모리 주소 변경됨
    - 문자열은 유사배열객체이면서 이터러블 - 배열과 유사하게 각 문자에 접근할 수 있다.
    - 그러나 일부문자에 접근하여 변경해도 반영은 X - 문자열은 변경 불가능한 값이기 때문
        - 유사배열객체
            
            마치 배열처럼 인덱스로 프로퍼티 값에 접근 할수 있음, length프로퍼티를 값는 객체
            
            배열처럼 인덱스를 통해 각문자에 접근 가능, for문으로 순회가능
            
        - 이터러블
3. 값에 의한 전달
    - 변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수에는 할당되는 변수의 **원시 값**이 복사되어 전달된다 - **값에 의한 전달**
    - 값은 같더라도 다른 메모리 공간에 저장된 별개의 값이다 - 서로 간섭 할 수가 없다.
    
    <aside>
    💡 var score  = 80;
    var copy = score;
    console.log(score, copy); //80 80
    console.log(score === copy); //true
    //값은 같지만 다른 메모리에 저장되어있다..
    score = 100; 
    console.log(score, copy); //100 80
    console.log(score === copy); //false
    //score값을 변경해도 copy 어떠한 영향도 없다..!
    
    </aside>
    
    - “값에 의한 전달”라도 하더라도 변수에는 값이 전달되는 것이 아니라 **메모리 주소가 전달** 되는 것
    
    ---
    
    ## 11.2 객체
    
    - 프로퍼티의 개수가 정해져 있지 않다
    - 동적으로 추가되고 삭제할 수 있다
    - 프로퍼티의 값에도 제약이없다.
    
    → **따라서 메모리 공간의 크기를 사전에 정해둘 수  없다.**
    
    - 원시 값은 상대적으로 적은 메모리를 소비, 객체는 경우에 따라 크기가 매우 클 수도 있다
    - 객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이 드는 일
    
    → **객체는 원시 값과 다른 방식으로 동작하도록 설계**
    
    1. 변경가능한 값
        - 객체(참조) 타입의 값은 **변경이 가능한 값**이다.
        - 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근
        - 원시값은 변경이 불가 - 재할당 외에는 방법이 없음
        **객체는 변경이 가능 - 재할당 없이 객체를 직접 변경 가능, 프로퍼티 추가, 갱신 삭제 가능**
        - 크기가 일정하지 X, 프로퍼티 값이 객체일수도 있고, 복사해서 생성하는 비용이 많이 듦 
        → 메모리를 효율적으로 사용하기 위해 변경이 가능한 값으로 설계
        - 구조적 단점에 따른 부작용 - 여러개의 식별자가 하나의 객체를 공유할 수 있다.
        
        - 깊은복사 얕은복사
            
            얕은 복사 : 한단계 까지만 복사
            
                               객체에 중첩 되어 있는 경우 참조 값을 복사
            
            깊은 복사 : 객체에 중첩되어있는 객체까지 모두 복사
            
                              객체에 중첩되어 있는 객체까지 원시 값처럼 완전한 복사본을 만든다.
            
            - 해당 부분은 일하면서 사용한 깊은 복사를 할 때 사용했던 방법 중 하나임
            객체에 함수가 존재할 시 사용하면 안됨
            그때는 Lodash라이브러리 _.cloneDeep함수 사용
            
            <aside>
            💡 var person1 = {name : ‘Lee’};
            var copy1 = person1; //얕은복사
            var copy2 = JSON.parse(JSON.stringify(person1));//깊은복사
            
            </aside>
            
    2. 참조에 의한 전달
        - 참조에 의한 전달 : 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사 되어 전달 → 두개의 식별자가 하나의 객체를 공유한다.
        - 원본 또는 사본 중 한쪽이 객체를 변경하면 서로 영향을 주고받는다.
        - 값에 의한 전달, 참조에 의한 전달
        식별자가 기억하는 메모리 공간에 저장되어있는 값을 복사한다는 것은 동일
        값이 원시값이냐, 참조값이냐의 차이
        → 해당 두개의 용어를 사용하지 않고 공유에 의한 전달이라고 표현하기도 한다.
        
        <aside>
        💡 var person1 = {name : ‘Lee’};
        var person2 = {name : ‘Lee’};
        console.log(person1 === person2); //false
        console.log(person1.name === person.name); //true
        
        </aside>
        
    
    ---
    
    ECMAScript?
    
    Ecma 인터내셔널에 의해 제정된 ECMA-262 기술 규격에 의해 정의된 범용 스크립트 언어
    
    javascript는 ECMAScript 사양을 준수하는 범용 스크립팅 언어이다.