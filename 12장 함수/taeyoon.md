# 12. 함수

## 함수란

- 함수는 **함수 정의**를 통해 생성
- 함수는 **호출에 의해 실행**이 되며 반환값을 반환

### *함수 리터럴

함수는 **객체 타입의 값이며,** 리터럴 형식으로 생성가능

```jsx
let sf = function sum(a,b){
	return a+b;
}

sf(1,2); //3
```

**일반 객체는 호출이 불가능하지만 함수는 호출이 가능

### *함수 정의

```jsx
//1.함수선언문
function f1(x,y){
	return x+y;
}

//2.함수 표현식
let f2 = function(x,y){
	return x + y;
}

//function 생성자 함수
let f3 = new Function('x','y','return x+y');

//화살표 함수
let f4 =(x,y) => x+y; //한줄일 때만 중괄호 생략 가능 

```

**화살표 함수를 사용시에는 **this에 대한 이슈**가 있으니 주의할 것 

**함수선언문은 함수이름 생략 불가능 // SyntaxError

⚠️**자바스크립트엔진**은 생성된 함수를 호출하기 위해 함수이름과 동일한 이름의 

식별자를 암묵적 생성하고, 거기에 함수 객체를 할당

함수는 함수이름이 아닌 **식별자를 찾아서 호출**

```jsx
let add = function sum(x,y){
	return x + y ;
}

console.log(add(1.2)); //3

console.log(sum(1,2)); // ReferenceError =>  참조할 함수 메모리주소를 찾을 수 없다.
```

### *함수 표현식

자바스크립트의 함수는 값처럼 **변수에 할당할 수 있고, 프로퍼티 값, 배열의 요소**가 될 수도 있다

이처럼 값의 성질을 갖는 객체를 **일급객체**라고 한다

### *함수 생성 시점과 함수 호이스팅

- **함수 선언문으로 정의한 함수**와 **함수 표현식으로 정의한 함수**의 생성 시점이 다르다.

⚠️ 함수 선언문은 코드의 선두로 끌어 올려진 것 처럼 작동(자바스크립트의 고유의 특징)

      단점으로는 **함수선언문 사용시 필요치 않은 메모리**를 사용할 수 있다4

//변수호이스팅과 함수호이스팅 차이

### *Function 생성자 함수

 자바스크립트가 기본 제공하는 **빌트인 함수인 Function** 생성자 함수

매개변수 목록과 함수 목체를 문자열로 전달하면서 new연산자와 함께 호출 시에 함수 객체 생성

```jsx
let sum = new Function('x','y','return x + y');
console.log(sum(1,2)); // 3
```

Function 생성자 함수로 생성한 함수는 **클로저 생성x**

### *함수 호출

- 인수(arg)는 값으로 평가 될 수 있는 표현식이어야 한다
- 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 **undefined로 초기화되고** 이후 순서대로 할당
- arg,param  개수에 제한은 없다

```jsx
//es6 문법으로 값이 없다면 0으로 초기화 

function sum(a,b,c){
	a = a || 0;
	b = b || 0;
	c = c || 0; //c의 값이 없다면 0으로 초기화
	return a + b + c;
}

// 초기화
function sum(a = 0 ,b = 0,c = 0){
	a = a || 0;
	b = b || 0;
	c = c || 0; //c의 값이 없다면 0으로 초기화
	return a + b + c;
}
console.log(sum(1,2)); //3
console.log(sum(1)); //1
```

### *반환문

함수는 return 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행결과를 함수 외부로 반환

⚠️반환문의 역할

1. 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져 나간다. **반환되면 그 이후의 문은 무시**
2. return 뒤에 오는 표현식을 평가해서 반환

**반환문은 함수 블록안에서 사용해야되지만 Node.js 모듈에서는 파일 바깥에 사용해도 에러 x

### *참조에 의한 전달과 외부 상태의 변경

```jsx
//매개변수 pri는 원시값을 전달 받고, 매게변수 obj는 객체를 전달받음
function changeVal(pri,obj){
	pri += 100;
	obj.name = 'Kim';
}

//함수 밖 
let num = 100;
let person = {name : 'Lee'};

console.log(num); //100
console.log(person) // {name:"Lee"}

//원시값은 값 자체가 복사되어 전달, 객체는 참조 값이 복사되어 전달
changeVal(num,person);

//num은 원시값이라 원본이 훼손되지 않음
console.log(num);//100 

//객체는 원본이 훼손
console.log(person); //{name:"Kim"}
```

참조에 의한 복사는 오류를 낫기에 **깊은 복사를 통해 새로운 객체를 생성하고 재할당**을 통해 

교체하는것이 좋다