# 14장 전역 변수의 문제점

전역 변수의 무분별한 사용은 위험하다. 전역 변수를 반드시 사용해야 할 이ㅠ를 찾지 못한다면 지역 변수를 사용해야 한다. 

그렇기 때문에 전역 변수의 문제점과 전역 변수의 사용을 억제할 수 있는 방법을 알아야 한다.

### 지역 변수의 생명 주기

- 변수는 생물과 유사하게 생성되고 소멸되는 생명주기가 있다.
- 변수에 생명 주기가 없다면 한번 선언된 변수는 프로그램을 종료할 때 까지 영원히 메모리 공감을 점유한다. (사람으로 치자면 영생하는 상태..?)
- 지역변수의 생명주기는 함수의 생명주기와 일치한다.
- 변수의 생명주기는 내부적으로 **메모리 공간 확보(생성) → 메모리 공간 해제(소멸)까지 이고 이후엔 가비지 컬렉터에 의해 가용 메모리 풀에 반환(반환)된다.**
- 그런데 만약 누군가 소멸 과정에서 해당 변수를 참조하면 소멸되지 않는다. (클로저가 이런 것을 할 수 있나봄..)

![https://dev-dobin.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fec8fa313-2975-4963-912d-8027604998fe%2F%25EC%25A7%2580%25EC%2597%25AD%25EB%25B3%2580%25EC%2588%2598%25EC%2583%259D%25EB%25AA%2585%25EC%25A3%25BC%25EA%25B8%25B0.png?id=b73ba399-5dfd-453e-af57-8cfaa94b19c4&table=block&spaceId=f800ef36-5d6f-4e98-a2f1-f4b2d48cc3fe&width=2000&userId=&cache=v2](https://dev-dobin.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fec8fa313-2975-4963-912d-8027604998fe%2F%25EC%25A7%2580%25EC%2597%25AD%25EB%25B3%2580%25EC%2588%2598%25EC%2583%259D%25EB%25AA%2585%25EC%25A3%25BC%25EA%25B8%25B0.png?id=b73ba399-5dfd-453e-af57-8cfaa94b19c4&table=block&spaceId=f800ef36-5d6f-4e98-a2f1-f4b2d48cc3fe&width=2000&userId=&cache=v2)

### 전역 변수의 생명 주기

- 함수와 달리 전역 코드는 명시적인 호출 없이 실행됨. 다시말해, 전역 코드는 함수 호출과 같이 전역코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행
- 전역 변수의 생명주기는 전역 객체의 생명주기와 동일하다.
- 즉, 전역 실행 컨텍스트가 종료되기까지 (브라우저일 경우 창을 닫을때 까지)전역 변수는 존재한다.

### 전역 변수의 문제점

### # 암묵적 결합

전역 변수는 어디서든 참조하고 할당할 수 있기 때문에 모든 코드가 전역 변수를 참조하고 변경할 수 있다는 뜻이다. 그렇기에 모든 코드는 전역변수와 암묵적으로 결합되어 있다고 볼 수 있다. 이는 변수의 유효 범위가 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경되는 부수효과 발생된다. 

### # 긴 생명 주기

프로그램이 종료될때 까지 살아있기 때문에 그만큼 메모리 리소스도 오랜 기간 소비한다 볼 수 있다. 그리고 오랜시간 생명주기가 긴 만큼 위 #암묵적 결합의 단점도 그 동안 만큼 유지된다. 또, 생명주기가 길면 var 키워드를 사용할 경우 변수이름이 중복되어 의도치 않은 재할당 될 위험성이 더욱 높아진다.

### # 스코프 체인 상에서 종점에 존재

실행 컨텍스트에서 봤듯이 스코프 체인을 통해 변수를 검색할 때, 만약 찾는 변수가 전역변수라면 스코프 체인의 길이만큼 전역 변수를 찾아가는 길 또한 길어진다. 그렇기 때문에 전역 변수의 검색 속도가 가장 느리다.

### # 네임스페이스 오염

자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

![https://dev-dobin.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7516a7bf-782a-45f4-815d-6d22061e180c%2F%25EC%25A0%2584%25EC%2597%25AD%25EB%25B3%2580%25EC%2588%2598%25EB%25AC%25B8%25EC%25A0%259C%25EC%25A0%2590.png?id=7092679b-1386-494d-b693-eca93e30f99a&table=block&spaceId=f800ef36-5d6f-4e98-a2f1-f4b2d48cc3fe&width=2000&userId=&cache=v2](https://dev-dobin.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7516a7bf-782a-45f4-815d-6d22061e180c%2F%25EC%25A0%2584%25EC%2597%25AD%25EB%25B3%2580%25EC%2588%2598%25EB%25AC%25B8%25EC%25A0%259C%25EC%25A0%2590.png?id=7092679b-1386-494d-b693-eca93e30f99a&table=block&spaceId=f800ef36-5d6f-4e98-a2f1-f4b2d48cc3fe&width=2000&userId=&cache=v2)

### 전역 변수의 사용을 억제하는 방법

- 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역변수를 사용
- 변수의 스코프는 좁을수록 좋다.

### # 즉시 실행 함수

- 바로 실행이 필요한 코드가 있다면 즉시 실행 함수를 사용하기

### # 네임스페이스 객체

- 전역에 네임스페이스(소속을 알리는 역할) 역할을 담당할 객체를 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

```jsx
var MYAPP = {};
MYAPP.name = "shin";

console.log(MYAPP.name); // shin

// 전역 변수를 세부적으로 구분하고 싶은 경우
var MYAPPS = {};
MYAPPS.person = {
	name : 'shin',
	age : '28'
};

MYAPP.dog = {
	name : 'Poppy',
	age : '1'
};

console.log(MYAPPS.human.name); // shin
```

### 모듈 패턴

- 모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만듦
- 모듈은 클로저를 기반으로 동작한다.
- 모듈 패턴은 전역 변수 억제와 캡슐화까지 구현할 수 있다.

> 캡슐화
캡슐화는 객체 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 한다.
> 

```jsx
var Counter = (function () {

	// private 멤버 변수
  var num = 0;

  // 클로저
	// 외부로 공개할 데이터나 메서드를 프로퍼티를 추가한 객체를 반환
  return {
		increase() {
			return ++num;
		},
		decrease() {
			return --num;
		},
		getNum() {
			return num;
		},
		setNum(argNum) {
			return num = argNum;
		}
    };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
console.log(Counter.setNum(5)); // 5
console.log(Counter.getNum()); // 5
console.log(Counter.increase()); // 6
console.log(Counter.decrease()); // 5
```

> 클로저
> 
> 
> 클로저란 이미 실행이 종료된 함수의 변수나 함수를 참조할 수 있는 링크를 가진 내부 함수를 뜻함.
> 
> 클로저의 핵심은 스코프를 이용해서, **변수의 접근 범위를 닫는데**에 있다.
> 
> 따라서 함수를 리턴하는 것 만큼이나 **변수가 선언된 위치**가 중요.
> 
> 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다.
> 이러한 중첩 함수를 **클로저**라고 부른다.
> 
> 일반적인 함수는 함수 실행이 끝나고 나면 함수 내부의 변수를 사용할 수 없다. 하지만 이와 다르게 **클로저**는 외부함수 실행이 끝나더라도 외부함수 내 변수가 메모리 상에 **저장** 된다. 내부 함수는 외부 함수에 선언된 변수에 접근 가능하다.
> 

### # ES6 모듈

ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다. 

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.

- 모듈에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.
- 사용법은 script 태그에 type = “module” 속성을 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.
- 모듈의 파일 확장자는 mjs를 권장

<aside>
💡 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는  ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.

</aside>